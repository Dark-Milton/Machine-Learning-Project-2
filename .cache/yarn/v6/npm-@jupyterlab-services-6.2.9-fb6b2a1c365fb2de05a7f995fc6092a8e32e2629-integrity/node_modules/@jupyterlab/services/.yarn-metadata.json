{
  "manifest": {
    "name": "@jupyterlab/services",
    "version": "6.2.9",
    "description": "Client APIs for the Jupyter services REST APIs",
    "keywords": [
      "jupyter",
      "notebook",
      "services"
    ],
    "homepage": "https://github.com/jupyterlab/jupyterlab",
    "bugs": {
      "url": "https://github.com/jupyterlab/jupyterlab/issues"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/jupyterlab/jupyterlab"
    },
    "license": "BSD-3-Clause",
    "author": {
      "name": "Project Jupyter"
    },
    "main": "lib/index.js",
    "browser": {
      "node-fetch": false,
      "ws": "./lib/shim/ws.js"
    },
    "typings": "lib/index.d.ts",
    "files": [
      "lib/**/*.js",
      "lib/*.js.map",
      "lib/**/*.d.ts",
      "lib/**/*.js.map",
      "lib/*.js",
      "lib/*.d.ts",
      "dist/*.js",
      "dist/**/*.js"
    ],
    "scripts": {
      "build": "tsc -b",
      "build:test": "tsc --build tsconfig.test.json",
      "clean": "rimraf lib && rimraf tsconfig.tsbuildinfo",
      "docs": "typedoc src",
      "test": "jest",
      "test:cov": "jest --collect-coverage",
      "test:debug": "node --inspect-brk node_modules/.bin/jest --runInBand",
      "test:debug:watch": "node --inspect-brk node_modules/.bin/jest --runInBand --watch",
      "watch": "tsc -b --watch"
    },
    "dependencies": {
      "@jupyterlab/coreutils": "^5.2.9",
      "@jupyterlab/nbformat": "^3.2.9",
      "@jupyterlab/observables": "^4.2.9",
      "@jupyterlab/settingregistry": "^3.2.9",
      "@jupyterlab/statedb": "^3.2.9",
      "@lumino/algorithm": "^1.3.3",
      "@lumino/coreutils": "^1.5.3",
      "@lumino/disposable": "^1.4.3",
      "@lumino/polling": "^1.3.3",
      "@lumino/signaling": "^1.4.3",
      "node-fetch": "^2.6.0",
      "ws": "^7.4.6"
    },
    "devDependencies": {
      "@jupyterlab/testutils": "^3.2.9",
      "@types/jest": "^26.0.10",
      "@types/node-fetch": "^2.5.4",
      "@types/text-encoding": "^0.0.35",
      "@types/ws": "^7.4.4",
      "jest": "^26.4.2",
      "rimraf": "~3.0.0",
      "text-encoding": "^0.7.0",
      "ts-jest": "^26.3.0",
      "typedoc": "~0.21.2",
      "typescript": "~4.1.3",
      "webpack": "^5.41.1",
      "webpack-cli": "^4.1.0"
    },
    "publishConfig": {
      "access": "public"
    },
    "_registry": "npm",
    "_loc": "/home/jupyter/.cache/yarn/v6/npm-@jupyterlab-services-6.2.9-fb6b2a1c365fb2de05a7f995fc6092a8e32e2629-integrity/node_modules/@jupyterlab/services/package.json",
    "readmeFilename": "README.md",
    "readme": "# JupyterLab Services\n\nJavascript client for the Jupyter services REST APIs\n\n[API Docs](http://jupyterlab.github.io/jupyterlab/)\n\n[REST API Docs](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml)\n\nNote: All functions and classes using the REST API allow a `serverSettings`\nparameter to configure requests.\nRequests are made using the `fetch` API, which is available in modern browsers\nor via `npm install fetch` for node users. The `whatwg-fetch` npm package\ncan be used to polyfill browsers that do not support the `fetch` API.\n\n## Package Install\n\n**Prerequisites**\n\n- [node](http://nodejs.org/)\n- [python](https://www.anaconda.com/distribution/)\n\n```bash\nnpm install --save @jupyterlab/services\nconda install notebook  # notebook 4.3+ required\n```\n\n## Source Build\n\n**Prerequisites**\n\nSee the [building instructions for JupyterLab](../../CONTRIBUTING.md), which\nwill build this module as part of the build process.\n\n**Rebuild**\n\n```bash\nyarn run clean\nyarn run build\n```\n\n## Run Tests\n\nFollow the source build instructions first.\n\n```bash\nyarn run test\n```\n\n## Build Docs\n\nFollow the source build instructions first.\n\n```bash\nyarn run docs\n```\n\nNavigate to `docs/index.html`.\n\n## Supported Runtimes\n\nThe runtime versions which should work are listed below. Earlier versions may\nalso work, but come with no guarantees.\n\n- Node 10\n- Firefox 52+\n- Chrome 55+\n\nNote: \"requirejs\" may need be included in a global context for `Comm` targets\nusing the a `target_module` (in the classic Notebook).\nThis can be as a `<script>` tag in the browser or by using the `requirejs`\npackage in node (`npm install requirejs` and setting\n`global.requirejs = require('requirejs');`).\n\n## Starting the Notebook Server\n\nFollow the package install instructions first.\n\nThe library requires a running Jupyter Notebook server, launched as:\n\n```bash\njupyter notebook\n```\n\nor\n\n```bash\njupyter lab\n```\n\n## Bundling for the Browser\n\nFollow the package install instructions first.\n\nSee `examples/browser` for an example of using Webpack to bundle the library.\n\n## Usage from Node.js\n\nFollow the package install instructions first.\n\nSee `examples/node` for an example of using an ES5 node script.\n\n## Usage Examples\n\n**Note:** This package is compiled to ES2017 JavaScript syntax from\nTypeScript. Here are some examples of using parts of this package. See the\nother `examples` subdirectories for more examples.\n\n- [Comms](./examples/browser/src/comm.ts)\n- [Config](./examples/browser/src/config.ts)\n- [Contents](./examples/browser/src/contents.ts)\n- [Kernel](./examples/browser/src/kernel.ts)\n- [Session](./examples/browser/src/session.ts)\n- [Terminal](./examples/browser/src/terminal.ts)\n\n## Overview\n\nThis package introduces a number of concepts, such as session context, etc.\nHere we give a brief overview of some of the top-level concepts in this\npackage.\n\n### Clients\n\nA _client_ is a single entity connected to a kernel. Since kernel messages\ninclude the client id, it is easy for a client to filter kernel messages for\njust messages between it and the kernel. In JupyterLab, different activities\n(such as a console and a notebook) are usually considered separate clients when\nconnected to the same kernel.\n\n### Kernel specs\n\nA _kernel spec_ is the data about an available kernel on the system. We can\nretrieve a current list of kernel specs from the server.\n\n### Kernels\n\nA _kernel_ represents a running process on the server that implements the\nJupyter kernel messaging protocol.\n\n#### Kernel model\n\nA _kernel model_ mirrors the server kernel models, and represents a single\nrunning kernel on the server. A kernel can be created, restarted, shut down,\netc., through calls to the server. A kernel model's lifecycle mirrors the\nserver kernel model's lifecycle, and it will be disposed when the server\nkernel is shut down.\n\n#### Kernel connection\n\nA _kernel connection_ represents a single client connecting to a kernel over a\nwebsocket. Typically only one kernel connection handles comms for any given\nkernel. The kernel connection is disposed when the client no longer has a need\nfor the connection. Disposing a kernel connection does not cause the kernel to\nshut down. However, if a kernel is shut down, (eventually) all of its kernel\nconnections should be disposed if they were initiated from a kernel manager.\nIf the kernel connections were instantiated outside of a manager, you are\nresponsible for cleaning them up.\n\nA kernel connection has a number of signals, such as kernel status, kernel\nconnection status, etc.\n\n#### Kernel manager\n\nA _kernel manager_ is an object that maintains a list of kernel models by\nregular polling. The kernel manager can instantiate a kernel connection and\nwill manage its lifecycle (e.g., when the kernel is shut down, the connections\nwill be disposed). The manager provides some minimal bookkeeping around\nkernels and their connections. Generally, it is easiest to interact with\nkernels on a server through a manager.\n\n### Sessions\n\nA _session_ is a mapping on the server from an identifying string (the\nsession's `path`) to a kernel. A session has a few other pieces of information\nto allow for easy categorization and searching of sessions.\n\nThe primary usecase of a session is to enable persisting a connection to a\nkernel. For example, a notebook viewer may start a session with session path\nof the notebook's file path. When a browser is refreshed, the notebook viewer\ncan connect to the same kernel by asking the server for the session\ncorresponding with the notebook file path.\n\n#### Session model\n\nA _session model_ mirrors a server session. The session models can be\nrefreshed from the server, created, changed (including creating a new session\nkernel), and shut down (which implies that the kernel will be shut down). A\nsession model's lifecycle mirrors the server session's lifecycle, and it will\nbe disposed when the server session is shut down.\n\n#### Session connection\n\nA _session connection_ represents a single client connected to a session's\nkernel. A session's kernel connection can change and may be null to signify no\ncurrent kernel connection. A session connection owns the kernel connection,\nmeaning the kernel connection is created and disposed by the session\nconnection as needed. The session connection proxies signals from the kernel\nconnection for convenience (e.g., you can listen to the session's status\nsignal to get status changes for whatever the current kernel is, without\nhaving to disconnect and reconnect your signal handlers every time the session\nkernel changes). The session connection can be disposed when the client no\nlonger is connected to that session's kernel, and disposal will not cause the\nsession model to be deleted.\n\n#### Session manager\n\nA _session manager_ is an object that maintains a list of session models by\nregular polling. The session manager can instantiate a session connection and\nwill manage its lifecycle (e.g., when the session is shut down, the connections\nwill be disposed). The manager provides some minimal bookkeeping around\nsessions and their connections. Generally, it is easiest to interact with\nsessions on a server through a manager.\n\n### Session Context\n\nA _session context_ is an object which has the same lifecycle as the client.\nThe session context owns a session connection (which may be null if the client\nis not currently associated with a session). The session context proxies the\ncurrent session connection's signals for convenience. The session context\nprimarily serves as a stable object for a client to keep track of the current\nsession connection. The session context also contains some convenience\nfunctionality, such as preferences for whether a kernel should be started and\na user-friendly kernel name and status.\n\nHere is a diagram that provides an overview of the different components:\n\n![architecture-diagram](./architecture.png)\n\n_The diagram can be edited on [diagrams.net](https://diagrams.net) by importing the [source](./architecture.xml)_.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@jupyterlab%2fservices/-/services-6.2.9.tgz#fb6b2a1c365fb2de05a7f995fc6092a8e32e2629",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@jupyterlab%2fservices/-/services-6.2.9.tgz",
    "hash": "fb6b2a1c365fb2de05a7f995fc6092a8e32e2629",
    "integrity": "sha512-6QzRBtTNE17I6/Kiid7qC2HQ4heAGWrX+vc1oNRHVv86ayzWiG3025qVNDm1QohykofUqRRYy8AHs0l84wfpDg==",
    "registry": "npm",
    "packageName": "@jupyterlab/services",
    "cacheIntegrity": "sha512-6QzRBtTNE17I6/Kiid7qC2HQ4heAGWrX+vc1oNRHVv86ayzWiG3025qVNDm1QohykofUqRRYy8AHs0l84wfpDg== sha1-+2sqHDZfst4Fp/mV/GCSqOMuJik="
  },
  "registry": "npm",
  "hash": "fb6b2a1c365fb2de05a7f995fc6092a8e32e2629"
}