{
  "manifest": {
    "name": "polybooljs",
    "version": "1.2.0",
    "description": "Boolean operations on polygons (union, intersection, difference, xor)",
    "main": "index.js",
    "repository": {
      "type": "git",
      "url": "https://github.com/voidqk/polybooljs"
    },
    "keywords": [
      "polygon",
      "union",
      "intersect",
      "intersection",
      "difference",
      "diff",
      "xor",
      "boolean",
      "clipping",
      "clip"
    ],
    "author": {
      "name": "Sean",
      "url": "http://syntheti.cc"
    },
    "license": "MIT",
    "_registry": "npm",
    "_loc": "/home/jupyter/.cache/yarn/v6/npm-polybooljs-1.2.0-b4390c2e079d4c262d3b2504c6288d95ba7a4758-integrity/node_modules/polybooljs/package.json",
    "readmeFilename": "README.md",
    "readme": "# polybooljs\n\nBoolean operations on polygons (union, intersection, difference, xor).\n\n# Features\n\n1. Clips polygons for all boolean operations\n2. Removes unnecessary vertices\n3. Handles segments that are coincident (overlap perfectly, share vertices, one inside the other,\n   etc)\n4. Uses formulas that take floating point irregularities into account (via configurable epsilon)\n5. Provides an API for constructing efficient sequences of operations\n6. Support for GeoJSON `\"Polygon\"` and `\"MultiPolygon\"` types (experimental)\n\n# Resources\n\n* [Demo + Animation](https://rawgit.com/voidqk/polybooljs/master/dist/demo.html)\n* [Companion Tutorial](http://syntheti.cc/article/polygon-clipping-pt2/)\n* Based somewhat on the F. Martinez (2008) algorithm:\n  [Paper](http://www.cs.ucr.edu/~vbz/cs230papers/martinez_boolean.pdf),\n  [Code](https://github.com/akavel/martinez-src)\n\n# Installing\n\n`npm install polybooljs`\n\nOr, for the browser, look in the [`dist/`](https://github.com/voidqk/polybooljs/tree/master/dist)\ndirectory for a single file build.  When included on a page, it will expose the global `PolyBool`.\n\n# Example\n\n```javascript\nvar PolyBool = require('polybooljs');\nPolyBool.intersect({\n    regions: [\n      [[50,50], [150,150], [190,50]],\n      [[130,50], [290,150], [290,50]]\n    ],\n    inverted: false\n  }, {\n    regions: [\n      [[110,20], [110,110], [20,20]],\n      [[130,170], [130,20], [260,20], [260,170]]\n    ],\n    inverted: false\n  });\n===> {\n  regions: [\n    [[50,50], [110,50], [110,110]],\n    [[178,80], [130,50], [130,130], [150,150]],\n    [[178,80], [190,50], [260,50], [260,131.25]]\n  ],\n  inverted: false\n}\n```\n\n![PolyBool Example](https://github.com/voidqk/polybooljs/raw/master/example.png)\n\n## Basic Usage\n\n```javascript\nvar poly = PolyBool.union        (poly1, poly2);\nvar poly = PolyBool.intersect    (poly1, poly2);\nvar poly = PolyBool.difference   (poly1, poly2); // poly1 - poly2\nvar poly = PolyBool.differenceRev(poly1, poly2); // poly2 - poly1\nvar poly = PolyBool.xor          (poly1, poly2);\n```\n\nWhere `poly1`, `poly2`, and the return value are Polygon objects, in the format of:\n\n```javascript\n// polygon format\n{\n  regions: [ // list of regions\n    // each region is a list of points\n    [[50,50], [150,150], [190,50]],\n    [[130,50], [290,150], [290,50]]\n  ],\n  inverted: false // is this polygon inverted?\n}\n```\n\n# GeoJSON (experimental)\n\nThere are also functions for converting between the native polygon format and\n[GeoJSON](https://tools.ietf.org/html/rfc7946).\n\nNote: These functions are currently **experimental**, and I'm hoping users can provide feedback.\nPlease comment in [this issue on GitHub](https://github.com/voidqk/polybooljs/issues/7) -- including\nletting me know if it's working as expected.  I don't use GeoJSON, but I thought I would take a\ncrack at conversion functions.\n\nUse the following functions:\n\n```javascript\nvar geojson = PolyBool.polygonToGeoJSON(poly);\nvar poly    = PolyBool.polygonFromGeoJSON(geojson);\n```\n\nOnly `\"Polygon\"` and `\"MultiPolygon\"` types are supported.\n\n# Core API\n\n```javascript\nvar segments = PolyBool.segments(polygon);\nvar combined = PolyBool.combine(segments1, segments2);\nvar segments = PolyBool.selectUnion(combined);\nvar segments = PolyBool.selectIntersect(combined);\nvar segments = PolyBool.selectDifference(combined);\nvar segments = PolyBool.selectDifferenceRev(combined);\nvar segments = PolyBool.selectXor(combined);\nvar polygon  = PolyBool.polygon(segments);\n```\n\nDepending on your needs, it might be more efficient to construct your own sequence of operations\nusing the lower-level API.  Note that `PolyBool.union`, `PolyBool.intersect`, etc, are just thin\nwrappers for convenience.\n\nThere are three types of objects you will encounter in the core API:\n\n1. Polygons (discussed above, this is a list of regions and an `inverted` flag)\n2. Segments\n3. Combined Segments\n\nThe basic flow chart of the API is:\n\n![PolyBool API Flow Chart](https://github.com/voidqk/polybooljs/raw/master/flowchart.png)\n\nYou start by converting Polygons to Segments using `PolyBool.segments(poly)`.\n\nYou convert Segments to Combined Segments using `PolyBool.combine(seg1, seg2)`.\n\nYou select the resulting Segments from the Combined Segments using one of the selection operators\n`PolyBool.selectUnion(combined)`, `PolyBool.selectIntersect(combined)`, etc.  These selection\nfunctions return Segments.\n\nOnce you're done, you convert the Segments back to Polygons using `PolyBool.polygon(segments)`.\n\nEach transition is costly, so you want to navigate wisely.  The selection transition is the least\ncostly.\n\n## Advanced Example 1\n\nSuppose you wanted to union a list of polygons together.  The naive way to do it would be:\n\n```javascript\n// works but not efficient\nvar result = polygons[0];\nfor (var i = 1; i < polygons.length; i++)\n  result = PolyBool.union(result, polygons[i]);\nreturn result;\n```\n\nInstead, it's more efficient to use the core API directly, like this:\n\n```javascript\n// works AND efficient\nvar segments = PolyBool.segments(polygons[0]);\nfor (var i = 1; i < polygons.length; i++){\n  var seg2 = PolyBool.segments(polygons[i]);\n  var comb = PolyBool.combine(segments, seg2);\n  segments = PolyBool.selectUnion(comb);\n}\nreturn PolyBool.polygon(segments);\n```\n\n## Advanced Example 2\n\nSuppose you want to calculate all operations on two polygons.  The naive way to do it would be:\n\n```javascript\n// works but not efficient\nreturn {\n  union        : PolyBool.union        (poly1, poly2),\n  intersect    : PolyBool.intersect    (poly1, poly2),\n  difference   : PolyBool.difference   (poly1, poly2),\n  differenceRev: PolyBool.differenceRev(poly1, poly2),\n  xor          : PolyBool.xor          (poly1, poly2)\n};\n```\n\nInstead, it's more efficient to use the core API directly, like this:\n\n```javascript\n// works AND efficient\nvar seg1 = PolyBool.segments(poly1);\nvar seg2 = PolyBool.segments(poly2);\nvar comb = PolyBool.combine(seg1, seg2);\nreturn {\n  union        : PolyBool.polygon(PolyBool.selectUnion        (comb)),\n  intersect    : PolyBool.polygon(PolyBool.selectIntersect    (comb)),\n  difference   : PolyBool.polygon(PolyBool.selectDifference   (comb)),\n  differenceRev: PolyBool.polygon(PolyBool.selectDifferenceRev(comb)),\n  xor          : PolyBool.polygon(PolyBool.selectXor          (comb))\n};\n```\n\n## Advanced Example 3\n\nAs an added bonus, just going from Polygon to Segments and back performs simplification on the\npolygon.\n\nSuppose you have garbage polygon data and just want to clean it up.  The naive way to do it would\nbe:\n\n```javascript\n// union the polygon with nothing in order to clean up the data\n// works but not efficient\nvar cleaned = PolyBool.union(polygon, { regions: [], inverted: false });\n```\n\nInstead, skip the combination and selection phase:\n\n```javascript\n// works AND efficient\nvar cleaned = PolyBool.polygon(PolyBool.segments(polygon));\n```\n\n# Epsilon\n\nDue to the beauty of floating point reality, floating point calculations are not exactly perfect.\nThis is a problem when trying to detect whether lines are on top of each other, or if vertices are\nexactly the same.\n\nNormally you would expect this to work:\n\n```javascript\nif (A === B)\n  /* A and B are equal */;\nelse\n  /* A and B are not equal */;\n```\n\nBut for inexact floating point math, instead we use:\n\n```javascript\nif (Math.abs(A - B) < epsilon)\n  /* A and B are equal */;\nelse\n  /* A and B are not equal */;\n```\n\nYou can set the epsilon value using:\n\n`PolyBool.epsilon(newEpsilonValue);`\n\nOr, if you just want to get the current value:\n\n`var currentEpsilon = PolyBool.epsilon();`\n\nThe default epsilon value is `0.0000000001`.\n\nIf your polygons are really really large or really really tiny, then you will probably have to come\nup with your own epsilon value -- otherwise, the default should be fine.\n\nIf `PolyBool` detects that your epsilon is too small or too large, it will throw an error:\n\n```\nPolyBool: Zero-length segment detected; your epsilon is probably too small or too large\n```\n\n# Build Log\n\nThe library also has an option for tracking execution of the internal algorithms.  This is useful\nfor debugging or creating the animation on the demo page.\n\nBy default, the logging is disabled.  But you can enable or reset it via:\n\n`var buildLog = PolyBool.buildLog(true);`\n\nThe return value is an empty list that will have log entries added to it as more API calls are made.\n\nYou can inspect the log by looking in the values:\n\n```javascript\nbuildLog.forEach(function(logEntry){\n  console.log(logEntry.type, logEntry.data);\n});\n```\n\nDon't rely on the build log functionality to be consistent across releases.\n\nYou can disable the build log via:\n\n`PolyBool.buildLog(false);`\n\nYou can get the current list (or `false` if disabled) via:\n\n`var currentLog = PolyBool.buildLog();`\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2016 Sean Connelly (@voidqk, web: syntheti.cc)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/polybooljs/-/polybooljs-1.2.0.tgz#b4390c2e079d4c262d3b2504c6288d95ba7a4758",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/polybooljs/-/polybooljs-1.2.0.tgz",
    "hash": "b4390c2e079d4c262d3b2504c6288d95ba7a4758",
    "integrity": "sha1-tDkMLgedTCYtOyUExiiNlbp6R1g=",
    "registry": "npm",
    "packageName": "polybooljs",
    "cacheIntegrity": "sha512-mKjR5nolISvF+q2BtC1fi/llpxBPTQ3wLWN8+ldzdw2Hocpc8C72ZqnamCM4Z6z+68GVVjkeM01WJegQmZ8MEQ== sha1-tDkMLgedTCYtOyUExiiNlbp6R1g="
  },
  "registry": "npm",
  "hash": "b4390c2e079d4c262d3b2504c6288d95ba7a4758"
}